<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Refresh" content="">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
	@font-face {
		font-family: tfont;
		src: url("./all/tfont.ttf") format("truetype");}

	@font-face{
		font-family: 'DH';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_three@1.0/designhouseOTFLight00.woff') format('woff');
    font-weight: normal;
    font-display: swap;
	}
	body,h1,h2,p,section{
		margin: 0;
		word-break: keep-all;}
	body{
		width: auto;
		height: 7800px;
		background-color: rgb(255, 253, 250 / 1.0);
 		 
	}
	h1{
		margin-top: 50px;
		padding-left: 80px;
		font-family: tfont;
		font-size: clamp(65px, 8vw, 140px);
		font-weight: 300;
		color: blue;
		text-decoration: none;
 		text-decoration: underline;
		text-decoration-color: blue;
		text-underline-offset: 12px;
		text-decoration-thickness: 3px;
	}

	.good{
		margin: 50px 0;
		font-family: tfont;
		font-weight: 300;
		font-size: clamp(20px, 4vw, 40px);
		padding-left: 100px;
		padding-right: 70px;
		line-height: 1.4;
		color: black;
	}

	.dotline{
		display: block;
		width: 95%;
		margin: 100px auto;
		}

	.box{
		width: 20%;
	 	margin-top: 90px;
	 	margin-left: 100px;
	  	padding: 35px;
	  	border: 2px solid #333;
	  	font-family: 'DH'; 
	  	font-size: 1rem;
	  	font-weight: 800;
		line-height: 1.8; 
		z-index: 10;
		}

	.nb{
	 	margin-left: 100px;
	  	font-family: 'DH'; 
	  	font-size: 1rem;
		line-height: 1.8; 
		z-index: 10;
		font-weight: 800;
	}


	.fl::first-letter {
	  font-size: 3.7rem;    
	  float: left;       
	  line-height: 0.8;  
	  margin-right: 15px;
	  margin-top: 10px;
	  font-weight: 1500;  
	  color: black;       
	}

	.fl1::first-letter {
	  font-size: 5.4rem;    
	  float: left;       
	  line-height: 0.8;  
	  margin-right: 16px;
	  margin-top: 19px;
	  font-weight: 1500;  
	  color: black;       
	}

	.ang{
		margin-top: -70px;
		width: 65%;
		margin-left: 450px;
		margin-right: 100px;
		z-index: 100;}

	.line {
 	margin: 100px auto;
    width: 97%;  
    height: 6px;  
    background-image: radial-gradient(circle, black 2px, transparent 2.5px);
    background-size: 10px 6px;
    background-repeat: repeat-x;
}

	.jick {
		width: 100%;
		background-color: black;
		height: 2px;
		margin: 60px auto;
		margin-bottom: 140px;
	}

/* 스크롤 구역~~~~ 만 모아놓음~~~~ 앙*/

    .track {
      height: 700vh;
      position: relative;
    }


    .masking {
      position: sticky;
      top: 55px;
      width: 95%;
      height: 85vh;
      overflow: hidden;
      margin: 0 auto;
      margin-bottom: 20px;
      perspective: 200px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background-color: blue;
      background-size: cover;
      background-position: center;
      z-index: 1;
    }

    .earth {
    	top: 300px;
      position: absolute;
      width: 70%; 
      z-index: 10; 
    }

    .tbox {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 20;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .t1 {
    	font-family: tfont;
      position: absolute;
      color: white;
      font-size: 60px;
      font-weight: 300;
      text-align: center;
      opacity: 0;
      transform: translateY(30px);
      transition: all 0.5s ease-out;
      text-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }

    .fire {
      opacity: 1;
      transform: translateY(0);
    }

    .machine {
    	width: 90%;
  		margin: 150px auto;
  		display: block;

    }

    .foot {
    	font-family: tfont;
    	justify-content: center;
    	align-items: center;
    	text-align: center;
      font-weight: 300;
      font-size: 40px;
    }

    .jeom {
    	display: flex;
    	width: 1.5%;
    	align-items: center;
    	justify-content: center;
    	margin: 80px auto;
    }
	</style>






</head>
<body>
	<section>
		<h1>
			LLM
		</h1>
			<div class="good">“LM (Language Model, 언어모델)은 입력값을
			기반으로 <br>통계학적으로 가장 적절한 출력값을
			출력하도록 학습된 모델이다.</div>

			<div class="good">LLM (Large Language Models, 대규모 언어모델)은 <br>규모가 큰 언어모델들을 말하며, 매개변수 규모가
			<br>막대한,  GPT-4 같은 모델들이 이에 해당한다.”
			</div>
	</section>
	<img src="./all/dotline.svg" class="dotline">
	<section>
		<div class="box"> 
			<p class="fl">LLM, 즉 거대 언어 모델은 말 그대로 '방대한 양의 텍스트 데이터'를 학습하여 인간의 언어를 이해하고  생성할 수 있도록 만들어진 인공지능 모델을 뜻한다. 
      <br><span style="margin-left: 40px;">쉽게 비유하자면,</span> LLM은 세상에 존재하는 
거의 모든 책, 인터넷 게시글, 논문 등을 읽은 ‘엄청나게 박식한 앵무새'와 같다. 하지만 이 앵무새는 자신이 말하는 내용의 '의미'를 깊이 이해하고 
진실을 말하는 것이 아니라, 수많은 문장을 읽어본 
경험을 토대로 "이 상황에서는 이런 단어가 나오는 게 자연스럽더라"라는 패턴을 학습한 존재이다.</div>
	<img src="./llm/ang.gif" class="ang">
	<div class="line"></div>
	</section>

  <div class="track" id="track">
    <div class="masking">
      
      <div class="bg"></div>

      <img src="./llm/earth.svg" class="earth" id="earth">
      
      <div class="tbox">
        <div class="t1 fire" style="font-size: 100px;">
            탄생과 발전 : "맥락"을 <br>
			이해하기 시작하다
        </div>
        
        <div class="t1">
            과거의 언어 모델들은 문장의<br>앞뒤 관계를 아주 짧게만 기억했다.
        </div>
        
        <div class="t1">
            그래서 긴 글을 쓰면 문맥이 뚝뚝 끊기거나<br> 엉뚱한 소리를 하기 일쑤였다.
        </div>
        	<div class="t1">
            하지만<br>2017년,
      		 </div>
      </div>

    </div>
  </div>

  <section class="box" style="width: 36%; margin-left: 120px;">
  		<p class="fl1" style="font-size: 2rem;">구글이 발표한 '트랜스포머(Transformer)'라는  <br>혁신적인 구조가 등장하면서 판도가 뒤집혔다. 
  		</p>
  	</section>

  	<section style="display: flex; flex-direction: column; align-items: flex-end;">
 	<div class="box" style="margin-right: 400px;">이 구조 덕분에 AI는 문장 전체에서 단어와 단어 사이의 보이지 않는 관계 (맥락)를 한꺼번에 파악할 수 있게 되었다. </div>
	<div class="box" style="margin-right: 120px; margin-top:-20px; background-color: white;">이후  OpenAI의 GPT 시리즈, 구글의 BERT 등이 등장하며 모델의 크기(파라미터)를 기하급수적으로 키웠고, 
	지금처럼 사람보다 더 유창하게 글을 쓰는 LLM이 탄생하게 
	되었다.</div>
</section>

<img src="./llm/machine.svg" class="machine">
<section style="display: flex; margin-top: -120px;">
	<section style="display: block; margin-left: -10px;" >
		<div class="box" style="width: 65%; margin-bottom: -20px;">LLM이 글을 쓰는 원리는 의외로 단순하다. 바로 ‘다음에 올 가장 적절한 단어(Token) 
	맞히기'이다. 위 그림처럼 LLM은 질문이 들어오면, 자신이 학습한 방대한 데이터 
	통계에 기반하여 다음에 올 단어의 확률을 계산한다.
	</div>
	<div class="box" style="width: 65%;;">입력: 사용자가 "대한민국의 수도는"이라고 입력한다.
	확률 계산: 모델은 수많은 단어 중 '서울'이 올 확률 90%, '부산'이 올 확률 5%, 
	      '워싱턴'이 올 확률 0.1%... 이런 식으로 계산한다.
	출력: 가장 확률이 높은(혹은 적절한) '서울'을 선택하여 내뱉는다.
	반복: "대한민국의 수도는 서울"을 다시 입력으로 삼아, 그 뒤에 올 단어("이다", 
	     "입니다" 등)를 예측한다.

	 이 과정은 트랜스포머(Transformer) 아키텍처를 통해 이루어진다.</div>
	</section>
	<section style="display: flex; flex-direction: column; align-items: flex-end; margin-left: ;">
	 <div class="box" style="width: 92%; margin-right: 90px;
	 padding-top: 49px; padding-bottom: 49px;">
	 	트랜스포머 구조의 핵심은 '어텐션(Attention)'이라는 기술이다. 이름 그대로 문장의 맥락을 
	파악하기 위해, AI가 중요한 단어에 스스로 '주목'하게 만드는 능력이다.<br>
	     <span style="margin-left: 40px;">예를</span> 들어 "그가 사과를 깎아 먹었다"라는 문장을 볼 때, AI는 단순히 단어를 나열하는 게 아니라 '먹었다'라는 행동과 가장 잘 어울리는 짝꿍인 '사과'에 더 집중한다. 이렇게 단어들 
	사이의 보이지 않는 관계를 파악해서, 글 전체의 숨은 의도까지 읽어내는 것이다. 
	<br>(트랜스포머 구조의 자세한 설명은 공과대학 수준의 과정이므로 여기선 다루지 않는다.)
	<br>
	<br>결국 LLM은 진실을 척척 알려주는 '똑똑한 박사님'이라기보다, 수많은 글을 읽으며 배운 패턴으로 "이럴 땐 이런 말을 하는 게 자연스럽더라"라며 확률을 계산하는 '글짓기 기계'에 가깝다. 
	AI에게 중요한 건 '이 말이 사실인가?'보다 '문맥상 자연스러운가?'이다. </div>
	</section>
</section>

<div class="jick"></div>

<img src="./all/jeom.svg" class="jeom">
<section style="margin: 0 auto;">
 <div class="foot">
 		<span style="color: blue;">LLM</span>은 
 		<br>
		<span style="color: blue;">거짓말</span>을
		<br>
		<span style="color: blue;">왜</span> 하는가
 </div>

 <div class="foot" style="font-size: 1rem; margin-top: 30px;">COPYRIGHT © ORKR.IN. ALL RIGHTS RESERVED.</div>
</section>
<img src="./all/foott.svg">
  <script>
const track = document.getElementById('track');
const earth = document.getElementById('earth');
const t1 = document.querySelectorAll('.t1');
const allt1 = t1.length; 

    window.addEventListener('scroll', () => {
      const rect = track.getBoundingClientRect();
      const trackHeight = track.offsetHeight - window.innerHeight;
      
      let progress = -rect.top / trackHeight;
      if (progress < 0) progress = 0;
      if (progress > 1) progress = 1;


      const moveY = progress * -80; 
      const rotateY = (progress * 30) - 15; 
      const rotateX = 10 - (progress * 20);
      const scale = 1 + (progress * 0.4); 

 let index = Math.floor(progress * allt1);
      if (index >= allt1) index = allt1 - 1;
      t1.forEach((item, i) => {
        if (i === index) {
          item.classList.add('fire');
        } else {
          item.classList.remove('fire');
        }
      });
      earth.style.transform = `translateY(${moveY}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
    });
  
  </script>
</body>
</html>